# typescript 进阶使用

## 函数重载

例如有一个函数 func，当接受字符串时候返回一个字符串，当接受一个字符串数组时返回一个字符串数组：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/GYVwdgxgLglg9mABKSAKAhgJwOYC5EDOUmMY2iAPocadgNoC6AlPkSWZde-Q4gN4AoRIgD0IxIFg5QMABgRTDAoYqALhMB52oAbnIYkwBTKCExIs2AQF8BAiAiKIAbugA2ITYgC8ycBFQByABabbtuB5MANymNvaaAHRQcAAycADumpgAwugEmqhMouIAopiYcJgCqGEOiGlctExRsQlJqemZ2YgACmkEAkA)
```ts
function func(arg: string | string[]): string | string[] {
  // 不考虑内部实现
  return arg
}

const value = func('hello');

value.toLowerCase() // Error
(value as string).toLowerCase() // Pass
```

可以点击试一试将鼠标放在 `value` 上面，会显示出 `value` 是 `string | string[]` 类型，并不是期望的 `string` 类型，这样在使用 `value` 的时候还需要使用类型断言来达到预期

更好的方式就是使用函数的重载：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0&ssl=11&ssc=28&pln=1&pc=1#code/PTAElnExfeNBGQYf8IU2hIc0L+KgHU0MryhAf4FADMBXAOwGMAXASwHsjRDSAKAQwCcBzALlAGcyWKibAJRde-QThARoAJkSpMueuWq1lzdqL4C2AbQC6IntsEHJYQHnagBucsgC5tA8IaBqJUAb+oDC5QJmKgTfjAVHLpAIW7WcIAocoDePoDR6oD0ZoAA6YCBkYAx2oAWioA+ioCd2oBQcoBG6X6AJHLeUOF++MQqNHTFGpzG4mygAD5VOgZGYjp1Dab6oADeOKCgLACmZAQstKw1UoCwcoDAAYCKYYChioAXCdY4AL44OCQ0vKAAbkwANgQDoAC8ZYwA5AAWAwcHVJdCOPtHAwB0ZFQAMlQA7gMWABhJjcAYMISgKQABVB3BwQA)
```ts
// 重载 1，没有函数体！
function func(arg: string): string
// 重载 2，没有函数体！
function func(arg: string[]): string[]
// 实现！注意别忘了写这个函数的实现，且类型是需要完全兼容上面的两个重载类型的
function func(arg: string | string[]): string | string[] {
  return arg // 不考虑内部实现
}

const value = func('hello')
value.toLowerCase() // Pass
```

可以看到 `value` 被按照预期的的推断出了 `string` 类型

再看一个例子加深印象，通过 `window.getComputedStyle` API 来获取一个元素的一个或一组样式值：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/GYVwdgxgLglg9mABAcwKZQMpQJ4BtUDOAFKrgFyIASAKgLIAyAovgLaphQA0iADgE5weFAlD4wwyAJTDR45AChQkWAhToseQiXJU6TVuy68BQxCLESA2gF1pZ2VeuLw0eEjSYc+YqQo0GzKhsHNz8gjIWyIgAPvaRNnbmcjFxcjaIAN7yiIgQCCKIACaoELiIALyIAO7ihXBVAHQeAMJwLDwgUKiFGvjaktmIMMCIRDg8qHAjYTwV5ZUA5EkSC5KZgzl86CB8SMWlTegACiaofDgAagCGuCCoRDMDOQC+g1tQO0gzDSxXPA8VAB8RRKuEOUBOgjOlxudwekgGr3keTABS2BAAjBU1J5NMQamA6o06hAQMEoA0AEZwQrYbgLYAIKAAWgIMAAXqhVogAPQ81ISZH5KCIdEAJmxHl6WgJRIaJLJhipNLpiEsDKZrI5XPpeVwcD4C1svP5y2QNnkQA)
```ts
function getStyles(el: HTMLElement, prop: string): string
function getStyles(el: HTMLElement, prop: string[]): string[]
function getStyles(el: HTMLElement, prop: string | string[]): string | string[] {
  const decl = window.getComputedStyle(el)
  if (typeof prop === 'string') {
    return decl.getPropertyValue(prop)
  }
  return prop.map(p => decl.getPropertyValue(p))
}

const res1 = getStyles(window.document.body, 'font-size') // string
const res2 = getStyles(window.document.body, ['font-size', 'color']) // string[]
```

## 泛型

看一下简单的泛型例子，是一个常用的类型工具：

```ts
type MaybeNull<T> = T | null
```

`<T>` 表示泛型，看起来像类型中的参数一下，这个参数的名称是任意合法的，如可是 V、Value 等

使用这个类型工具：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/C4TwDgpgBAsghiARhAcgVwDYYDwBUB8UAvFLlAD5QB2mGAUHRhMNWgLYBcsCy6W2NNsgBOhEgEZGzKAGdgwrvCSpa2OcICWVAOZioAcnVbt+hluARhAMzgBjaAAVLMgPZUoAbzpRqcNhC4jHToAXwYmFjBFHhV+J2FXKj0aLCA)
```ts
type MaybeNull<T> = T | null

let num: MaybeNull<number> = 1
let str: MaybeNull<string> = 'string'

interface Person {
  name: string
}

let p: MaybeNull<Person> = null
```

回到函数重载中的第一个例子：

_有一个函数 func，当接受字符串时候返回一个字符串，当接受一个字符串数组时返回一个字符串数组_

也可以用泛型的方式（这并不代表泛型和函数重载一样，只是这个例子特殊）：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0&ssl=6&ssc=28&pln=1&pc=1#code/GYVwdgxgLglg9mABKSAeAKgPgBQEMBOA5gFyLoCUp6iA3gFCKL4CmUI+SBhiA9D4oFg5QMABgRTDAoYqALhMB52oAbnOgF86dCAgDOURADdcAGxDNEAXmTgI2AOQALZjp1xz5Otr3MAdFDgAZOAHdm+AGFcVWZscl5+AAVg1SA)
```ts
function func<T>(arg: T): T {
  return arg // 不考虑内部实现
}

const value = func('hello')
value.toLowerCase() // Pass
```

箭头函数语法，将泛型写在函数参数之前：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0&ssl=6&ssc=28&pln=1&pc=1#code/MYewdgzgLgBAZgVzMGBeGAeAKgPgBQCGATgOYBcMWAlBVmjjAN4BQMMRAplAkWDMSRgB6ITECwcoGAAwIphgUMVAFwmA87UANzswC+zZqEiwAbgQA2CDmnhJgeAOQALDvv0gLVZnsMcAdFBAAZEAHcORADCBBAceFTCogAKIRBAA)
```ts
const func = <T>(arg: T): T => {
  return arg // 不考虑内部实现
}

const value = func('hello')
value.toLowerCase() // Pass
```

### 泛型默认值

和函数参数一样，泛型参数也可以有默认值：

```ts
type Factory<T = boolean> = T | number | string
```

当不给泛型参数时，`T` 的值将会是 `boolean` 类型：

```ts
type Factory<T = boolean> = T | number | string
let foo: Factory = false // 没有给泛型参数
```

### 泛型约束

期望的泛型参数类型可以给一些约束类型：

```ts
type Result<T extends number> = T | 0
```

这里约束 `T` 必须是 `number` 的子类型，子类型暂时理解为更具体的类型，如字面量 `100` 类型一定是 `number` 类型，`number` 类型不一定是字面量 `100` 类型，使用例子：

```ts
type Result<T extends number> = T | 0

let code: Result<100> = 0 // Pass（这里的 100 是 typescript 中的数字字面量类型，不是实际的 js 值，编译后会被移除）
code = 100 // Pass
```

有一个例子：


