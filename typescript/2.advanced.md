# typescript 进阶使用

## 泛型

泛型可以使用在函数中，来使用泛型的方式重写函数重载中的第一个例子

_有一个函数 func，当接受字符串时候返回一个字符串，当接受一个字符串数组时返回一个字符串数组_

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/GYVwdgxgLglg9mABKSAeAKgPgBQEMBOA5gFyLoCUp6iA3gFCKL4CmUI+SBhiA9D4oFg5QMABgRTDAoYqALhMB52oAbnOgF86dCAgDOURADdcAGxDNEAXmTgI2AOQALZjp1xz5Otr3MAdFDgAZOAHdm+AGFcVWZscl5+AAVg1SA)
```ts
function func<T>(arg: T): T {
  return arg // 不考虑内部实现
}

const value = func('hello')
value.toLowerCase() // Pass
```

箭头函数语法，将泛型写在函数参数之前：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0&ssl=6&ssc=28&pln=1&pc=1#code/MYewdgzgLgBAZgVzMGBeGAeAKgPgBQCGATgOYBcMWAlBVmjjAN4BQMMRAplAkWDMSRgB6ITECwcoGAAwIphgUMVAFwmA87UANzswC+zZqEiwAbgQA2CDmnhJgeAOQALDvv0gLVZnsMcAdFBAAZEAHcORADCBBAceFTCogAKIRBAA)
```ts
const func = <T>(arg: T): T => {
  return arg // 不考虑内部实现
}

const value = func('hello')
value.toLowerCase() // Pass
```

泛型可以使用在类中：

```ts
class Queue<T> {
  // 定义在类名上的泛型参数可以使用在成员属性和方法上
  container: T[] = []
  
  // 定义在类名上的泛型参数可以使用在成员属性和方法上
  push(val: T) {
    this.container.push(val)
  }
}
```

类中的方法也可以有自己的泛型：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/MYGwhgzhAECKCuBTJAeAKgPmgbwFDWmAHsA7AFzAEsTEAnALmjQG0BdaAXmjf2l4Ad4EABYAKAG5gQjNAEocvAmWGUIAOmLkqNWmsEiJU2bwC+uXkWV0AYvBLAUAaQyiwtAOYBGGQBpob9wAmRkd5PAICAHpI6AATImgIIgBbRGVqd1NcEyA)
```ts
class Queue<T> {
  container: T[] = []
  
  push(val: T) {
    this.container.push(val)
  }

  otherFunc<K>(arg1: T, arg2: K) {
    // do something
  }
}
```

泛型可以使用在 interface 中：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/JYOwLgpgTgZghgYwgAgArQM4HsQB4AqAfMgN4BQyyIcAthAFzIZhSgDmFyA1hAJ6P4yAXzJkEOZsgAOjdFGx4ARliwAbCHBDEAvKU7U6jAOQAPYBCMAaTj37IWAVwjCgA)
```ts
interface Person<T> {
  name: string
  key: T
}

const p: Person<boolean> = {
  name: 'xie',
  key: true
}
```

泛型可以使用在 type 中，称为工具类型：

```ts
type MaybeNull<T> = T | null
```

使用这个类型工具：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/C4TwDgpgBAsghiARhAcgVwDYYDwBUB8UAvFLlAD5QB2mGAUHRhMNWgLYBcsCy6W2NNsgBOhEjSx1BxKAEYATAGZGzKAGdgwrvCSpa2DcICWVAOZjWkwzIDkhk6ZsMTwCMIBmcAMbQACm7UAeyooAG86KGo4NgguezM6AF8VFjBtHj1+f2EgqgsJejAZUKiYrhsADyMIGyhEoA)

```ts
type MaybeNull<T> = T | null

let num: MaybeNull<number> = null
num = 123
let str: MaybeNull<string> = null
str = 'string'

interface Person {
  name: string
}
let p: MaybeNull<Person> = null
p = { name: 'xie' }
```

### 泛型默认值

和函数参数一样，泛型参数也可以有默认值：

```ts
type Factory<T = boolean> = T | number | string
```

当不给泛型参数时，`T` 的值将会是 `boolean` 类型：

```ts
type Factory<T = boolean> = T | number | string
let foo: Factory = false // 没有给泛型参数
```

### 泛型约束

期望的泛型参数类型可以给一些约束类型：

```ts
type Result<T extends number> = T | 0
```

这里约束 `T` 必须是 `number` 的子类型，子类型暂时理解为更具体的类型，如字面量 `100` 类型一定是 `number` 类型，`number` 类型不一定是字面量 `100` 类型，使用例子：

```ts
type Result<T extends number> = T | 0

// Pass（这里的 100 是 typescript 中的数字字面量类型，不是实际的 js 值，编译后会被移除）
let code: Result<100> = 0
code = 100 // Pass
```

再看一个例子：

[试一试](https://www.typescriptlang.org/play?target=99&jsx=0#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyGcAngFzIAUAlMgLwB8yAblsACYEC+BBoSLEQoAWgAs4IAMpT8RZHADmEKiACuAWwBG0BaUo16zNh258CMdSARhgOEuQASEADausAHgAqyCAA9IEE4MNEwcJmosbQArKm96QmJomIA6AzpefgQcDDBkAAcqdChsXAZ8RzI6fB5kPhyQPOQAL0kmqSoJKVlyyuVVZAAmAAYAGiqavDqLAxd3LGoC+gB6FbQ4DAwCObcPajapUhBV9dRNjCA)
```ts
interface Person {
  say: () => void
}

interface ZhanSan {
  age: number
  say: () => void
}

function sayHello<T extends Person>(obj: T) {
  obj.say()
}

const p: Person = { say() {} }
const zhansan: ZhanSan = { age: 20, say() {} }

sayHello(p) // Pass
sayHello(zhansan) // Pass
```

需要注意的是在 typescript 中使用的是结构化类型系统，所谓的子类型并不是使用了 `extends` 关键字才是子类型，主要比目标类型更具体就是子类型，如上面代码中 `sayHello` 方法接受一个对象，该对象必须是 `Person` 类型或其子类型，但第二次方法调用时，传递给了函数 `ZhanSan` 类型也是可以的，因为 `ZhanSan` 有 `Person` 类型的全部兼容字段，即 `ZhanSan` 是 `Person` 的子类型